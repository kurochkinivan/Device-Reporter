// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package pipeline_test

import (
	"context"

	"github.com/kurochkinivan/device_reporter/internal/domain"
	mock "github.com/stretchr/testify/mock"
)

// NewMockFilesProvider creates a new instance of MockFilesProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFilesProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFilesProvider {
	mock := &MockFilesProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockFilesProvider is an autogenerated mock type for the FilesProvider type
type MockFilesProvider struct {
	mock.Mock
}

type MockFilesProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFilesProvider) EXPECT() *MockFilesProvider_Expecter {
	return &MockFilesProvider_Expecter{mock: &_m.Mock}
}

// Files provides a mock function for the type MockFilesProvider
func (_mock *MockFilesProvider) Files(ctx context.Context) ([]*domain.File, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Files")
	}

	var r0 []*domain.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*domain.File, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*domain.File); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockFilesProvider_Files_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Files'
type MockFilesProvider_Files_Call struct {
	*mock.Call
}

// Files is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockFilesProvider_Expecter) Files(ctx interface{}) *MockFilesProvider_Files_Call {
	return &MockFilesProvider_Files_Call{Call: _e.mock.On("Files", ctx)}
}

func (_c *MockFilesProvider_Files_Call) Run(run func(ctx context.Context)) *MockFilesProvider_Files_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockFilesProvider_Files_Call) Return(files []*domain.File, err error) *MockFilesProvider_Files_Call {
	_c.Call.Return(files, err)
	return _c
}

func (_c *MockFilesProvider_Files_Call) RunAndReturn(run func(ctx context.Context) ([]*domain.File, error)) *MockFilesProvider_Files_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockFileUpdater creates a new instance of MockFileUpdater. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFileUpdater(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFileUpdater {
	mock := &MockFileUpdater{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockFileUpdater is an autogenerated mock type for the FileUpdater type
type MockFileUpdater struct {
	mock.Mock
}

type MockFileUpdater_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFileUpdater) EXPECT() *MockFileUpdater_Expecter {
	return &MockFileUpdater_Expecter{mock: &_m.Mock}
}

// UpdateOrCreateFile provides a mock function for the type MockFileUpdater
func (_mock *MockFileUpdater) UpdateOrCreateFile(ctx context.Context, file *domain.File) error {
	ret := _mock.Called(ctx, file)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrCreateFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.File) error); ok {
		r0 = returnFunc(ctx, file)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockFileUpdater_UpdateOrCreateFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrCreateFile'
type MockFileUpdater_UpdateOrCreateFile_Call struct {
	*mock.Call
}

// UpdateOrCreateFile is a helper method to define mock.On call
//   - ctx context.Context
//   - file *domain.File
func (_e *MockFileUpdater_Expecter) UpdateOrCreateFile(ctx interface{}, file interface{}) *MockFileUpdater_UpdateOrCreateFile_Call {
	return &MockFileUpdater_UpdateOrCreateFile_Call{Call: _e.mock.On("UpdateOrCreateFile", ctx, file)}
}

func (_c *MockFileUpdater_UpdateOrCreateFile_Call) Run(run func(ctx context.Context, file *domain.File)) *MockFileUpdater_UpdateOrCreateFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.File
		if args[1] != nil {
			arg1 = args[1].(*domain.File)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockFileUpdater_UpdateOrCreateFile_Call) Return(err error) *MockFileUpdater_UpdateOrCreateFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockFileUpdater_UpdateOrCreateFile_Call) RunAndReturn(run func(ctx context.Context, file *domain.File) error) *MockFileUpdater_UpdateOrCreateFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDevicesSaver creates a new instance of MockDevicesSaver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDevicesSaver(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDevicesSaver {
	mock := &MockDevicesSaver{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockDevicesSaver is an autogenerated mock type for the DevicesSaver type
type MockDevicesSaver struct {
	mock.Mock
}

type MockDevicesSaver_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDevicesSaver) EXPECT() *MockDevicesSaver_Expecter {
	return &MockDevicesSaver_Expecter{mock: &_m.Mock}
}

// SaveDevices provides a mock function for the type MockDevicesSaver
func (_mock *MockDevicesSaver) SaveDevices(ctx context.Context, devices ...*domain.Device) error {
	var tmpRet mock.Arguments
	if len(devices) > 0 {
		tmpRet = _mock.Called(ctx, devices)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for SaveDevices")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...*domain.Device) error); ok {
		r0 = returnFunc(ctx, devices...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDevicesSaver_SaveDevices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveDevices'
type MockDevicesSaver_SaveDevices_Call struct {
	*mock.Call
}

// SaveDevices is a helper method to define mock.On call
//   - ctx context.Context
//   - devices ...*domain.Device
func (_e *MockDevicesSaver_Expecter) SaveDevices(ctx interface{}, devices ...interface{}) *MockDevicesSaver_SaveDevices_Call {
	return &MockDevicesSaver_SaveDevices_Call{Call: _e.mock.On("SaveDevices",
		append([]interface{}{ctx}, devices...)...)}
}

func (_c *MockDevicesSaver_SaveDevices_Call) Run(run func(ctx context.Context, devices ...*domain.Device)) *MockDevicesSaver_SaveDevices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*domain.Device
		var variadicArgs []*domain.Device
		if len(args) > 1 {
			variadicArgs = args[1].([]*domain.Device)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockDevicesSaver_SaveDevices_Call) Return(err error) *MockDevicesSaver_SaveDevices_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDevicesSaver_SaveDevices_Call) RunAndReturn(run func(ctx context.Context, devices ...*domain.Device) error) *MockDevicesSaver_SaveDevices_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTransactor creates a new instance of MockTransactor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTransactor(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTransactor {
	mock := &MockTransactor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTransactor is an autogenerated mock type for the Transactor type
type MockTransactor struct {
	mock.Mock
}

type MockTransactor_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTransactor) EXPECT() *MockTransactor_Expecter {
	return &MockTransactor_Expecter{mock: &_m.Mock}
}

// WithTransaction provides a mock function for the type MockTransactor
func (_mock *MockTransactor) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTransactor_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type MockTransactor_WithTransaction_Call struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(ctx context.Context) error
func (_e *MockTransactor_Expecter) WithTransaction(ctx interface{}, fn interface{}) *MockTransactor_WithTransaction_Call {
	return &MockTransactor_WithTransaction_Call{Call: _e.mock.On("WithTransaction", ctx, fn)}
}

func (_c *MockTransactor_WithTransaction_Call) Run(run func(ctx context.Context, fn func(ctx context.Context) error)) *MockTransactor_WithTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTransactor_WithTransaction_Call) Return(err error) *MockTransactor_WithTransaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTransactor_WithTransaction_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context) error) error) *MockTransactor_WithTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReportGenerator creates a new instance of MockReportGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReportGenerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReportGenerator {
	mock := &MockReportGenerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReportGenerator is an autogenerated mock type for the ReportGenerator type
type MockReportGenerator struct {
	mock.Mock
}

type MockReportGenerator_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReportGenerator) EXPECT() *MockReportGenerator_Expecter {
	return &MockReportGenerator_Expecter{mock: &_m.Mock}
}

// GenerateReport provides a mock function for the type MockReportGenerator
func (_mock *MockReportGenerator) GenerateReport(outputPath string, unitGUID string, sourceFile string, devices []*domain.Device) error {
	ret := _mock.Called(outputPath, unitGUID, sourceFile, devices)

	if len(ret) == 0 {
		panic("no return value specified for GenerateReport")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string, string, []*domain.Device) error); ok {
		r0 = returnFunc(outputPath, unitGUID, sourceFile, devices)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockReportGenerator_GenerateReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateReport'
type MockReportGenerator_GenerateReport_Call struct {
	*mock.Call
}

// GenerateReport is a helper method to define mock.On call
//   - outputPath string
//   - unitGUID string
//   - sourceFile string
//   - devices []*domain.Device
func (_e *MockReportGenerator_Expecter) GenerateReport(outputPath interface{}, unitGUID interface{}, sourceFile interface{}, devices interface{}) *MockReportGenerator_GenerateReport_Call {
	return &MockReportGenerator_GenerateReport_Call{Call: _e.mock.On("GenerateReport", outputPath, unitGUID, sourceFile, devices)}
}

func (_c *MockReportGenerator_GenerateReport_Call) Run(run func(outputPath string, unitGUID string, sourceFile string, devices []*domain.Device)) *MockReportGenerator_GenerateReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []*domain.Device
		if args[3] != nil {
			arg3 = args[3].([]*domain.Device)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockReportGenerator_GenerateReport_Call) Return(err error) *MockReportGenerator_GenerateReport_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockReportGenerator_GenerateReport_Call) RunAndReturn(run func(outputPath string, unitGUID string, sourceFile string, devices []*domain.Device) error) *MockReportGenerator_GenerateReport_Call {
	_c.Call.Return(run)
	return _c
}
